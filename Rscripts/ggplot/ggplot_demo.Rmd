---
title: "ggplot_demo"
author: "Janet Young\n"
date: "`r Sys.Date()`\n"
output: github_document
always_allow_html: true
---


Show some examples from the [ggplot2 cheatsheet](https://rstudio.github.io/cheatsheets/html/data-visualization.html)


```{r setup, include=FALSE}
library(tidyverse)
```

These commands set up a few base plots, but they have no geom layer, so nothing is actually plotted
```{r}
## economics is a 574-row 6-col tibble. colnames:
# date, pce, pop, psavert, uempmed, unemploy
a <- ggplot(economics, aes(date,unemploy))

## seals is a 1155-row 4-col tibble. colnames:
# lat  long delta_long delta_lat
b <- ggplot(seals, aes(x=long, y=lat))
# ?seals 
# "This vector field was produced from the data described in..."
### each longitude value in seals is present 21 times, each latitude 55 times
# seals %>% count(long) %>% count(n)
# seals %>% count(lat)  %>% count(n)
# it's simply a grid in x-y space
```

I wanted to explore a bunch of different geoms

```{r, fig.height=2, fig.width=5}
# Ensure limits include values across all plots.
a + geom_blank() + labs(title="geom_blank")
## they also show + expand_limits()
```

```{r}
b + geom_point() + labs(title="geom_point")
```

```{r}
## this is a wierd thing to demo
b + geom_curve(aes(xend = long + 1, 
                   yend = lat + 1), 
               curvature = 1) + 
    labs(title="geom_curve")
# Draw a curved line from (x, y) to (xend, yend). 
# aes() arguments: x, xend, y, yend, alpha, angle, color, curvature, linetype, size.
# x and y already existed in b
```

```{r}
a + 
    geom_path(lineend = "butt", linejoin = "round", linemitre = 1) +
    labs(title="geom_path")
# Connect observations in the order they appear. aes() arguments: x, y, alpha, color, group, linetype, size.
```

`geom_line()` connects points from left to right
`geom_path()` is similar but connects points in the order they appear in the data
so if data are sorted, the graphs look the same

```{r}
a + 
    geom_path(lineend = "butt", linejoin = "round", linemitre = 1) +
    coord_cartesian(xlim=c(date("1970-01-01"),date("1975-01-01"))) +
    labs(title="geom_path")
# Connect observations in the order they appear. aes() arguments: x, y, alpha, color, group, linetype, size.
```

Same thing with geom_line - looks the same (because data are sorted, geom_path IS connected left-to-right, just like geom_line)
```{r}
a + 
    geom_line(lineend = "butt", linejoin = "round", linemitre = 1) +
    coord_cartesian(xlim=c(date("1970-01-01"),date("1975-01-01"))) +
    labs(title="geom_line")
# Connect observations in the order they appear. aes() arguments: x, y, alpha, color, group, linetype, size.
```

```{r}
a + geom_polygon(aes(alpha = 50)) +
    labs(title="geom_polygon")
# Connect points into polygons. aes() arguments: x, y, alpha, color, fill, group, subgroup, linetype, size.
```

geom_rect demo

```{r}
## the example given makes it hard to see what's going on , so I sample 30 rows at random
# b + geom_rect(aes(xmin = long, ymin = lat, xmax = long + 1, ymax = lat + 1))
# Draw a rectangle by connecting four corners (xmin, xmax, ymin, ymax). aes() arguments: xmax, xmin, ymax, ymin, alpha, color, fill, linetype, size.
seals %>% 
    slice_sample(n=30) %>% 
    ggplot(aes(xmin = long, ymin = lat, 
               xmax = long + 1, ymax = lat + 1)) + 
    geom_rect() +
    labs(title="geom_rect")
```

`geom_ribbon()`

```{r}
a + geom_ribbon(aes(ymin = unemploy - 900, 
                    ymax = unemploy + 900)) +
    labs(title="geom_ribbon")
# For each x, plot an interval from ymin to ymax. aes() arguments: x, ymax, ymin, alpha, color, fill, group, linetype, size.
```


# two variables
```{r}
# mpg is a 234 Ã— 11 tibble, with various car types
e <- ggplot(mpg, aes(cty,hwy))
```

`geom_point()`
```{r}
e+geom_point() +
    labs(title="geom_point")
```

```{r}
e+geom_point()+geom_smooth()+
    labs(title="geom_point and geom_smooth")
```


# shadowtext package

Demo from [rfortherestofus](https://rfortherestofus.com/2024/05/shadowtext-ggplot)

Mostly I don't like the way shadowtext looks, but it could be really useful if we're putting words over the top of some other dense data, e.g. words on top of a map benefit from a white shadow

```{r}
### to install missing fonts:
# library(showtext) # For fonts
# font_add_google("Source Sans Pro") ## downloads and installs a font, except I don't think it necessarily makes the font available always?  maybe I need to restart the computer before I can use it?
# grep("Source", system_fonts()$name, value=TRUE)
# grep("Times", system_fonts()$name, value=TRUE)
# grep("Arial", system_fonts()$name, value=TRUE)
```

```{r}
library(shadowtext)
library(palmerpenguins)
```



```{r}
## define labelling info
species_labels_tib <- tibble(
  species = c('Adelie', 'Gentoo', 'Chinstrap'),
  x = c(35, 43, 53),
  y = c(210, 229, 178)
)
```

We can use geom_shadowtext() pretty much the same as we'd use geom_label, using bg.color to tell it the color of the shadow. 

```{r}
## the plot
penguins |> 
    drop_na() |>
  ggplot(
    aes(bill_length_mm, flipper_length_mm, fill = species)
  ) +
  geom_point(shape = 21, size = 4) +
  geom_shadowtext(
    data = species_labels_tib,
    aes(x, y, col = species, label = species),
    size = 12,
    fontface = 'bold',
    family = 'ArialMT',
    bg.color = 'grey10',
  )  +
  theme_minimal(base_size = 16, base_family = 'ArialMT') +
  theme(legend.position = 'none')

```



