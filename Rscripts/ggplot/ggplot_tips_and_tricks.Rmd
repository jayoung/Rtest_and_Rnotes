---
title: "ggplot_tips_and_tricks"
author: "Janet Young\n"
date: "`r Sys.Date()`\n"
output: github_document
always_allow_html: true
---

# Goal 

A place to collect various ggplot tips and tricks

```{r setup, echo=TRUE, results='hide', warning=FALSE, message=FALSE}
## the above is a good chunk header for chunks that load libraries
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(patchwork)
library(here)
library(palmerpenguins)

library(ggExtra)  ## for ggMarginal
library(shadowtext)
library(ggtext)
library(ggbreak) 

### for my_ggMarginal:
source(here("useful_functions/other_functions.R"))
```

# Public ggplot2 resources

[ggplot2 gallery](https://www.r-graph-gallery.com/ggplot2-package.html)

[ggplot2 extensions gallery](https://exts.ggplot2.tidyverse.org/gallery/) - shows various packages that extent ggplot. Examples (but there are many many more):
- patchwork and cowplot to combine plots 
- gganimate 
- ggstatsplot (and ggsignif) to add results of statistical tests, 
- gggenomes and gggenes

A ggplot [tutorial](https://rgup.gitlab.io/research_cycle/02_ggplot.html)

[Demos](https://www.datanovia.com/en/lessons/combine-multiple-ggplots-into-a-figure/#google_vignette) of how to combine >1 plot into a figure. Packages: 

- gridExtra::grid.arrange() 
- cowplot::plot_grid() 
- patchwork::plot_layout() 
- ggpubr::ggarrange() 

https://www.thoughtworks.com/insights/blog/coding-habits-data-scientists


# ggplot2 versions

ggplot2 version 4 is a big change, and may break some things in other packages.

I don't want to update to it yet.  That may mean I need to use older versions of some other packages.

Here's how I can install a particular archive version of a package once I identify the URL on CRAN:

```{r}
# ### revert back to ggplot 3.5.2 - this is from 2025-04-09 
# ## version 4.0.0 is
# packageurl <- "http://cran.r-project.org/src/contrib/Archive/ggplot2/ggplot2_3.5.2.tar.gz"
# install.packages(packageurl, repos=NULL, type="source")

### revert back to GGally 2.2.1 (2024-02-14). Newer versions need ggplot2 version 4.4.0
# # GGally_2.2.0.tar.gz
# packageurl <- "http://cran.r-project.org/src/contrib/Archive/GGally/GGally_2.2.1.tar.gz"
# install.packages(packageurl, repos=NULL, type="source")
```


# Adding median dots to violin plots: geom_violin + stat_summary

Purpose:  make violin plots, and add statistical summaries (e.g. a dot for the median)

I often have trouble getting the statistical summary (median dot) to line up correctly if I've got subgroupings for the violins. The trick is something to do with putting `position=position_dodge(width=0.9)` in the stat_summary call

```{r, fig.height=3, fig.width=5}
mtcars %>% ggplot(aes(x=factor(cyl), y=mpg, fill = factor(am))) + 
    geom_violin(scale = "width") + 
    stat_summary(fun = "mean", colour = "black", 
                 position=position_dodge(width=0.9),
                 size = 2, geom = "point")
```


# Annotating plots - `annotate()` versus `geom_text()`

`annotate()` is better than `geom_text()` for some uses. 

Demo based on [rfortherestofus](https://rfortherestofus.com/2023/10/annotate-vs-geoms)

- use geom_text if the data itself should drive text labels
- use annotate if you're manually adding labels

Example where annotate is better

```{r, fig.height=5, fig.width=5}
scatterplot <- palmerpenguins::penguins %>% 
    select(bill_length_mm, flipper_length_mm, species) %>% 
    drop_na()%>% 
    ggplot(aes(bill_length_mm, flipper_length_mm, col = species)) +
    geom_point(size = 2.5) +
    labs(
        x = 'Bill length (in mm)',
        y = 'Flipper length (in mm)',
        col = 'Species',
        title = 'Measurements of different Penguin Species'
    ) +
    theme_minimal(base_size = 16) +
    theme(legend.position = 'top')
```


Here we use `geom_text()` and it looks bad, because it is still drawing stuff (color) from the data passed in, and that's not what we want

```{r, fig.height=5, fig.width=5}
scatterplot +
    geom_text(
        x = 35,
        y = 217.5,
        label = 'Important penguins',
        fontface = 'bold', # makes text bold
        size = 4.5 # font size
    )
```

Here we use `annotate()` instead and it ignores the data

```{r, fig.height=5, fig.width=5}
scatterplot +
    annotate(
        'text',
        x = 35,
        y = 217.5,
        label = 'Important penguins',
        fontface = 'bold', 
        size = 4.5
    )

```


# Explore `shadowtext` package

Demo from [rfortherestofus](https://rfortherestofus.com/2024/05/shadowtext-ggplot)

Mostly I don't like the way shadowtext looks, but it could be really useful if we're putting words over the top of some other dense data, e.g. words on top of a map benefit from a white shadow


```{r}
### revert back to shadowtext 0.1.4 (2024-07-18). Newer versions need ggplot2 version 4.4.0
# packageurl <- "https://cran.r-project.org/src/contrib/Archive/shadowtext/shadowtext_0.1.4.tar.gz"
# install.packages(packageurl, repos=NULL, type="source")
```

```{r, echo=TRUE, results='hide', warning=FALSE, message=FALSE}
### to install missing fonts:
# library(showtext) # For fonts
# font_add_google("Source Sans Pro") ## downloads and installs a font, except I don't think it necessarily makes the font available always?  maybe I need to restart the computer before I can use it?
# grep("Source", system_fonts()$name, value=TRUE)
# grep("Times", system_fonts()$name, value=TRUE)
# grep("Arial", system_fonts()$name, value=TRUE)
```



```{r, fig.height=2, fig.width=5}
## define labelling info
species_labels_tib <- tibble(
    species = c('Adelie', 'Gentoo', 'Chinstrap'),
    x = c(35, 43, 53),
    y = c(210, 229, 178)
)
```

We can use geom_shadowtext() pretty much the same as we'd use geom_label, using bg.color to tell it the color of the shadow. 

```{r, fig.height=4, fig.width=5}
## the plot
penguins %>% 
    drop_na() %>%
    ggplot(
        aes(bill_length_mm, flipper_length_mm, fill = species)
    ) +
    geom_point(shape = 21, size = 2) +
    geom_shadowtext(
        data = species_labels_tib,
        aes(x, y, col = species, label = species),
        size = 6,
        fontface = 'bold',
        family = 'ArialMT',
        bg.color = 'grey10',
    )  +
    theme_minimal(base_size = 16, base_family = 'ArialMT') +
    theme(legend.position = 'none')
```

# Wrapping text over >1 line in ggplot

`str_wrap()` - you have to figure out width manually, which can be tedious

```{r, fig.height=3, fig.width=5}
penguins %>% 
    count(island) %>%
    ggplot(aes(x=island, y=n)) +
    geom_col() +
    labs(title="a short title",
         subtitle=str_wrap("a really long title. kasjdhf ;isjdghf khg kajsxdhf khg alsidgf kjhg ljhags dfj hgkjahsdgfkjhg a  ljhsdgf ljhglsdjhfg", width=50))
```

Instead use `ggtext` package - the element_textbox_simple will automatically wrap text to fit whatever space is available.

```{r, fig.height=3, fig.width=5}
penguins %>% 
    count(island) %>%
    ggplot(aes(x=island, y=n)) +
    geom_col() +
    labs(title="a short title",
         subtitle="a really long title. kasjdhf ;isjdghf khg kajsdhf khg alsidgf kjhg ljhags dfj hgkjahsdgfkjhg a  ljhsdgf ljhglsdjhfg") +
    theme(plot.subtitle = element_textbox_simple())
```

Maybe we need to wrap facet labels - we can use the label_wrap_gen function

```{r, fig.height=3, fig.width=5}
theme_set(theme_bw(16))
df <- data.frame(measurement = rnorm(20,mean=30), 
                 group = c(rep('A really long group variable name that needs to be wrapped',10),
                           rep('group1',10)), 
                 sex = c(rep(c('M','F'),10)))

df %>%
    ggplot(aes(sex, measurement, color = sex)) +
    geom_boxplot() +
    facet_wrap(~group, labeller = label_wrap_gen(width=24))+
    theme(legend.position="none")
```



# Discontinuous axes using `ggbreak` package

`ggbreak` package [vignette](https://cran.r-project.org/web/packages/ggbreak/vignettes/ggbreak.html)

there is a blank plot below, as well as the intended plots, but it doesn't appear when you knit to html or github_document

```{r, fig.height=4, fig.width=7}
set.seed(2019-01-19)
d <- data.frame(x = 1:20,
                y = c(rnorm(5) + 4, rnorm(5) + 20, rnorm(5) + 5, rnorm(5) + 22)
)

p1 <- ggplot(d, aes(y, x)) + 
    geom_col(orientation="y") +
    theme_minimal() +
    labs(title="ordinary x-axis")
p2 <- p1 + 
    scale_x_break(c(7, 17)) + # from ggbreak
    labs(title="broken x-axis")


p1 + p2
```

# Add marginal density plots

We use [`ggExtra::ggMarginal`](https://github.com/daattali/ggExtra) to add marginal density plots.

We do it a slightly weird way because it's a ggExtraPlot object not a regular ggplot object - see [this note](https://github.com/daattali/ggExtra?tab=readme-ov-file#using-ggmarginal-in-r-notebooks-or-rmarkdown)

```{r, fig.height=4, fig.width=5}
## first make a basic plot
p1 <- penguins %>% 
    drop_na() %>%
    ggplot(
        aes(bill_length_mm, flipper_length_mm, color = species)
    ) +
    geom_point(size = 1) +
    theme_classic() + 
    ## legend needs to be at bottom (or left) so it doesn't push the density plot away from the main plot
    theme(legend.position="bottom") 

## then use ggMarginal
p1a <- ggMarginal(p1, type="density", groupColour = TRUE)
```

```{r, fig.height=4, fig.width=5}
p1a
```


If we want to use patchwork to combine >1 ggMarginal plot, we need to use the `wrap_elements()` function:


```{r, fig.height=4, fig.width=10}
patchwork::wrap_elements(p1a) + patchwork::wrap_elements(p1a)
```

[A known issue with ggMarginal](https://github.com/daattali/ggExtra/issues/128) - it doesn't respect coord_cartesian settings on the main plot:

```{r, fig.height=4, fig.width=5}
p1b <- p1 +
    coord_cartesian(xlim=c(0,60)) 
p1b <- ggMarginal(p1b, type="density", groupColour = TRUE)
```

```{r, fig.height=4, fig.width=5}
p1b
```

A workaround is to use `xlim` rather than coord_cartesian. The downside of that is that it actually REMOVES data outside the specified range, so the density plots are not accurate.

```{r, fig.height=4, fig.width=5}
p1b <- p1 +
    xlim(c(0,60))
p1b <- ggMarginal(p1b, type="density", groupColour = TRUE)
```

```{r, fig.height=4, fig.width=5}
p1b
```

We can also do it in basic ggplot (including changing the axis limits).   I made a function to do that - it's called `my_ggMarginal()` and is in `useful_functions/other_functions.R`

Show that function:

```{r}
print(my_ggMarginal)
```

```{r}
my_penguin_colors <- c(Adelie="orange",
                       Gentoo="purple",
                       Chinstrap="forestgreen")
penguins %>%  
    drop_na() %>% 
    my_ggMarginal(x_var="bill_length_mm",
                  y_var="flipper_length_mm", color_var="species",
                  my_xlim=c(0,60), my_ylim=c(160,240),
                  my_color_scheme=my_penguin_colors,
                  my_title="penguins",
                  my_subtitle = "by species")
```




`geom_rug()` is an alternative way to show the marginal distributions:

```{r}
p1 +
    geom_rug(alpha=.2,
             length = unit(0.1, "inches")) 
## default length is unit(0.03, "npc"), i.e. 0.03* the plot dimensions (so the x and y axis rugs might be different lengths, unless we control that)
```




# Finished

```{r}
sessionInfo()
```

