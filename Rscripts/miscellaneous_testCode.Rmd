---
title: "miscellaneous_testCode"
author: "Janet Young\n"
date: "`r Sys.Date()`\n"
output: github_document
always_allow_html: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(janitor)
```

# basic tidyverse

```{r}
m <- mtcars |> as_tibble()

## show counts in each category
m |> 
    count(cyl)
```

## pivot_longer with multiple columns



Example data from [stackoverflow](https://stackoverflow.com/questions/61367186/pivot-longer-into-multiple-columns)

```{r}

dat <- tribble(
    ~group,  ~BP,  ~HS,  ~BB, ~lowerBP, ~upperBP, ~lowerHS, ~upperHS, ~lowerBB, ~upperBB,
    "1", 0.51, 0.15, 0.05,     0.16,     0.18,      0.5,     0.52,     0.14,     0.16,
    "2.1", 0.67, 0.09, 0.06,     0.09,     0.11,     0.66,     0.68,     0.08,      0.1,
    "2.2", 0.36, 0.13, 0.07,     0.12,     0.15,     0.34,     0.38,     0.12,     0.14,
    "2.3", 0.09, 0.17, 0.09,     0.13,     0.16,     0.08,     0.11,     0.15,     0.18,
    "2.4", 0.68, 0.12, 0.07,     0.12,     0.14,     0.66,     0.69,     0.11,     0.13,
    "3", 0.53, 0.15, 0.06,     0.14,     0.16,     0.52,     0.53,     0.15,     0.16)

dat
```

First we pivot_longer using names_pattern argument

```{r}
longer <- dat |> 
    pivot_longer(cols=-group, 
                 names_pattern = "(.*)(..)$", 
                 names_to = c("limit", "name")) |> 
    mutate(limit=ifelse(limit=="", "value", limit))
longer
```

Then we pivot wider to get the data how we really want it to look:


```{r}
answer <- longer |> 
    pivot_wider(id_cols = c(group, name), 
                names_from = limit, values_from = value, 
                names_repair = "check_unique")
answer
```

Alternative in one step, using the special `.value` tag for the `names_to` argument:

```{r}
dat |> 
    rename_with(~sub("^(BP|HS|BB)$", "values\\1", .)) |>     # add prefix values
    pivot_longer(cols= -1,
                 names_pattern = "(.*)(BP|HS|BB)$",
                 names_to = c(".value", "names")) 
```


## separate_longer trick (for list-like columns), and str_replace_all trick (multiple find-replaces)

From [here](https://rfortherestofus.com/2024/04/seperate-fcts)

```{r}

details <- readr::read_csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-01-25/details.csv",
                           show_col_types = FALSE)
board_games <- details |>
    select(id, name = primary, boardgamecategory)

board_games |> 
    head(3)
```

```{r}
board_games |>
    separate_longer_delim(cols = boardgamecategory, delim = ", ") |>
    mutate(
        boardgamecategory = str_replace_all(
            boardgamecategory,
            c(
                # pattern_to_replace = replacement
                # We have to wrap the names in backticks because all of the things we want to replace are special characters and R doesn’t like them in vector names if they’re not in backticks
                `[` = "",
                `]` = "",
                `"` = "",
                `'` = ""
            ) |> 
                coll() ## coll() tells str_replace_all() that we explicitly do not want to use regular expressions.
        ))
```

## barplots of counts in each category

```{r}
m |> 
    ggplot(aes(x=as.factor(cyl))) +
    geom_bar()
```

## adding number of observations (or other statistical summaries) to faceted plot


### Example 1 - geom_point, with n= labels in each facet

Here the statistical summary applies to all observations in the facet together.

```{r, fig.height=3.5, fig.width=6}
## calculate the summary stats separately.
# note that the facetting variable (Species) is a column in the summary 
iris_summary <- iris |> 
    group_by(Species) |> 
    summarize(label = dplyr::n()) |> 
    mutate(label=paste0("n = ", label)) |> 
    ## use the entire dataset (not grouped) to get x and y coords for the n= labels
    mutate(x=min(iris$Sepal.Length)*1.1) |> 
    mutate(y=max(iris$Petal.Length)*1.1)

## then make the plot
iris |> 
    ggplot(aes(x=Sepal.Length, y=Petal.Length, color=Species)) +
    geom_point() +
    geom_text(data=iris_summary, 
              aes(label=label, y=y, x=x)) +
    facet_wrap(vars(Species)) +
    theme_classic() +
    guides(color="none")
```

### Example 2

Each facet is a geom_boxplot.

Here the statistical summary applies to each group within each facet.


```{r}
## get example data in long format
iris_long <- iris |> 
    pivot_longer(cols=-Species, names_to="variable", values_to="value")

## make a function to produce the labels we want
stat_box_data <- function(y) {
    ## weirdly this works fine if I return a data.frame, but if I make it a tibble the count and mean are both wrong
    # data_summary <- tibble(
    data_summary <- data.frame(
        y = 0.5+1.1*max(y),  # may need to modify this depending on your data
        label = paste('count =', length(y), '\n',
                      'mean =', round(mean(y), 1), '\n') )
    return(data_summary)
}

ggplot(data = iris_long, aes(x=Species, y=value)) + 
    geom_boxplot(aes(fill=Species)) +
    stat_summary(
        fun.data = stat_box_data, 
        geom = "text", 
        hjust = 0.5,  vjust = 0.9 ) + 
    facet_wrap( ~ variable, scales="free")
```

## tribble - a way to manually create small tibbles, row-wise

```{r}
tribble(
    ~colA, ~colB,
    "a",   1,
    "b",   2,
    "c",   3
)
# same as:
tibble(colA=c("A","B","C"), 
       colB=1:3)
```

## the purrr::map functions are a bit like lapply / apply

```{r}
1:10 |>
    map(rnorm, n = 10)


# do something to each column
mtcars |> map_dbl(sum)

# split into list, then map.  
# we need to use the magrittr pipe (%>%) so that split can access .
# map_dbl simplify output, in this case to a dbl (or numeric)
# same for map_lgl(), map_int() and map_chr()
mtcars %>%
    split(.$cyl) %>%
    map(~ lm(mpg ~ wt, data = .x)) |>
    map(summary) |>
    map_dbl("r.squared")

# map_dfr tries to return a data.frame (binding by rows)  (map_dfc is similar but binds by columns)
mtcars %>%
    split(.$cyl) %>%
    map(~ lm(mpg ~ wt, data = .x)) |>
    map_dfr(~ as.data.frame(t(as.matrix(coef(.)))))
```

`setNames()` is a way to set names on a list - can be used in a pipe as an alternative to adding a separate `names(x) <- y` after a set of piped commands


# variable names - using variables

## bang-bang

"bang-bang" , a.ka. !!  performs "name injection"

it's explained more [here](https://dplyr.tidyverse.org/articles/programming.html#name-injection)

To see more info: ?rlang::`!!`

here I use it in dplyr::rename - we use `!!` to interpret the variable and then we have to use `:=` (instead of =)
```{r}
newVarName <- "sepalLen_new"
iris |> 
    dplyr::rename(!!newVarName := Sepal.Length) |> 
    head()
```

There's also something called ["bang-bang-bang"](https://www.reddit.com/r/Rlanguage/comments/g5m5bh/what_does_the_bang_bang_bang_do/?rdt=45180)

## embracing operator

The 'embracing' operator (`{{ }}`) is useful when we want to pass in variable(s) that we want to be interpreted before being used. It's related to !! and !!!

more discussion [here](https://rlang.r-lib.org/reference/embrace-operator.html),  [here](https://rlang.r-lib.org/reference/topic-data-mask.html) and  [here](https://adv-r.hadley.nz/quasiquotation.html)

The embracing operator is [similar to](https://www.r-bloggers.com/2019/07/bang-bang-how-to-program-with-dplyr/), but not identical to !! ("bang-bang"). It's also [similar to](https://www.reddit.com/r/Rlanguage/comments/g5m5bh/what_does_the_bang_bang_bang_do/?rdt=45180), but not identical to !!! ("bang-bang-bang")

Example:

```{r}
### this wouldn't work
## first define a function
get_var0 <- function(data, column, value) {
    data |> filter(column == value)
}
## then use it - gives an error this way
# get_var0(mtcars, cyl, 6)
#> Error: Problem with `filter()` input `..1`.
#> x object 'cyl' not found
#> i Input `..1` is `column == value`.

## gives empty tbl output this way (wrong, should be 7):
# get_var0(mtcars, "cyl", 6)

### this DOES work
get_var1 <- function(data, column, value) {
    data |> filter({{ column }} == value)
}
get_var1(mtcars, cyl, 6)
```

### !!! example: 

from [here](https://www.reddit.com/r/Rlanguage/comments/g5m5bh/what_does_the_bang_bang_bang_do/?rdt=45180)

To see more info: ?rlang::`!!!`

```{r}
## Let's say we want to select the first 3 columns of a data frame. So you can do something like this:
test_df <- tibble(a = 1, b = 1, c = 1, d = 1)
test_df |>
    select(1, 2, 3)
```

```{r}
## Easy enough. Now let's say we have a list of values that we want to use to replicate the code above. Now if you pass this to the select function it fails:
our_list <- list(1, 2, 3)
# test_df |>
#     select(our_list)
## That's because that code essentially translates to this, which doesn't work.
# test_df |>
#     select(list(1, 2, 3))

# What we need to do is "unpack" the list using !!!.
test_df |>
    select(!!!our_list)
# which translates to this:
# test_df |>
#     select(1, 2, 3)
```


# adding metadata / attributes

I had a use case where I wanted to associate a few bits of info with a tibble of data. The actual example is that my tibble contained genome-wide t-test results, and I wanted to record exactly what method I'd used to do the t-tests)

Note that `attr()` and `atrributes()` are different functions


```{r}
# make example tibble:
a <- 1:5
b <- tibble(a, a * 2)

### add attributes under the methods tag (there can be:
attr(b, "methods") <- "here's some text about the method"
attr(b, "details") <- "here's some more detail about the method"

## access the metadata:
attr(b, "methods")
```

```{r}
## show all attributes:
attributes(b)
```

https://github.com/sfirke/packagemetrics?tab=readme-ov-file

```{r}
# devtools::install_github("sfirke/packagemetrics")
library("packagemetrics")
dplyr_and_dt <- package_list_metrics(c("dplyr", "data.table"))
# data frame
```

```{r}
metrics_table(dplyr_and_dt)
```

