---
title: "compare_two_genomes_dotplot_demo"
author: "Janet Young\n"
date: "`r Sys.Date()`"
output: github_document
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(tidyverse)
library(kableExtra)
library(patchwork)

#install.packages(devtools)
devtools::install_github("dwinter/pafr")
library(pafr)
```

# Overview

The `pafr` package looks very nice for generating whole-genome dotplots from paf files (and doing other analysis), which are generated by minimap2 comparisons of one **query** genome against a second **target** genome.

I tried this in the worm_mitoNuc project.

# Resources

`pafr` package [github project page](https://dwinter.github.io/pafr/) and [documentation website](https://dwinter.github.io/pafr/index.html) are useful.

The [minimap documentation](https://lh3.github.io/minimap2/minimap2.html#10) contains a description of paf output format.

# Demo code

Read an example paf file. It generates a pafr class object, which behaves a bit like a tibble.

```{r read example paf file}
ali <- read_paf( system.file("extdata", "fungi.paf", package="pafr") )
ali
```
pafr class objects can be treated like tibbles, and easily coerced to tibbles:

```{r}
ali %>% 
    filter(qname=="Q_chr3") %>% 
    select(-qlen) %>% 
    as_tibble() %>% 
    head(10)
```


Here are the column names of this particular pafr object. When I read my own minimap file, I didn't have all of these fields.  Below I copy info from the [minimap documentation](https://lh3.github.io/minimap2/minimap2.html#10) about these fields.

```{r}
names(ali)
```
```
1	string	Query sequence name
2	int	Query sequence length
3	int	Query start coordinate (0-based)
4	int	Query end coordinate (0-based)
5	char	‘+’ if query/target on the same strand; ‘-’ if opposite
6	string	Target sequence name
7	int	Target sequence length
8	int	Target start coordinate on the original strand
9	int	Target end coordinate on the original strand
10	int	Number of matching bases in the mapping
11	int	Number bases, including gaps, in the mapping
12	int	Mapping quality (0-255 with 255 for missing)

tp	A	Type of aln: P/primary, S/secondary and I,i/inversion
cm	i	Number of minimizers on the chain
s1	i	Chaining score
s2	i	Chaining score of the best secondary chain
NM	i	Total number of mismatches and gaps in the alignment
MD	Z	To generate the ref sequence in the alignment
AS	i	DP alignment score
SA	Z	List of other supplementary alignments
ms	i	DP score of the max scoring segment in the alignment
nn	i	Number of ambiguous bases in the alignment
ts	A	Transcript strand (splice mode only)
cg	Z	CIGAR string (only in PAF)
cs	Z	Difference string
dv	f	Approximate per-base sequence divergence
de	f	Gap-compressed per-base sequence divergence
rl	i	Length of query regions harboring repetitive seeds
```

# Explore alignment statistics 

## Distribution of alignment lengths

```{r}
# the 'tp' field is for the type of alignment - I want more understandable labels on my plots:
tp_labeller <- c(P="primary", S="secondary", I="inversion")
```

```{r}
ali %>% 
    mutate(tp=toupper(tp)) %>% 
    ggplot(aes(alen)) + 
    geom_histogram(colour="black", fill="steelblue", bins=20) + 
    theme_bw() + 
    ggtitle("Distribution of alignment lengths") +
    scale_x_log10("Alignment length") +
    facet_grid(rows=vars(tp), scales = "free",
               labeller = labeller(tp=tp_labeller))
```

## Alignment length versus per-base divergence

```{r}
ali %>% 
    filter(!is.na(dv)) %>% 
    ggplot(aes(x=alen, y=dv, color = tp)) + 
    geom_point(alpha=0.4, size=2) + 
    scale_x_continuous("Alignment length (kb)",
                       label =  function(x) x/ 1e3) +
    # scale_x_log10("Alignment length") +
    scale_y_continuous("Per base divergence") +
    scale_color_discrete(name="Aln type", labels=tp_labeller) +
    theme_bw() 
```

## dotplots

```{r}
dotplot(ali, label_seqs = TRUE) +
    theme_bw()
```


Here's the same dotplot, but changing the aesthetics of the text labels for each chromosome
```{r}
# GeomLabel$default_aes$size  ## 3.88
update_geom_defaults("text", list(size = 2, color="darkred"))
dotplot(ali, label_seqs = TRUE) +
    theme_bw()
# restore geom_text defaults after we finish dotplots
update_geom_defaults("text", list(size = 3.88, color="black"))
```
Zoom in to a particular query or target chromosome:

```{r}
# GeomLabel$default_aes$size  ## 3.88
update_geom_defaults("text", list(size = 2, color="darkred"))
ali %>% 
    filter(qname=="Q_chr4" & tp=="P" & alen>=50000) %>% 
    dotplot(label_seqs = TRUE) +
    theme_bw()
# restore geom_text defaults after we finish dotplots
update_geom_defaults("text", list(size = 3.88, color="black"))
```

Choose order in which chromosomes are displayed

```{r}
update_geom_defaults("text", list(size = 2, color="darkred"))

my_chr_order <- list()
my_chr_order[[1]] <- unique(ali$qname)
my_chr_order[[1]] <- my_chr_order[[1]] [ length(my_chr_order[[1]]):1 ]
my_chr_order[[2]] <- unique(ali$tname)

ali %>% 
    dotplot(label_seqs=TRUE, 
            order_by="provided", ordering=my_chr_order,
            xlab="new query axis label",
            ylab="new target axis label") +
    theme_bw()
update_geom_defaults("text", list(size = 3.88, color="black"))
```
Zoom using coord_cartesian (I suppress messages, otherwise it tells me I'm adding to existing coordinate system)

```{r}
update_geom_defaults("text", list(size = 2, color="darkred"))
p1 <- ali %>% 
    dotplot(label_seqs=TRUE) +
    theme_bw()
suppressMessages( p1zoom <- p1 + 
                      coord_cartesian(xlim=c(1.2*10^7,1.8*10^7),
                                      ylim=c(1.7*10^7,2.3*10^7)) )
p1 + p1zoom
update_geom_defaults("text", list(size = 3.88, color="black"))
```

Can add annotations, too - see the pafr documentation.

# Synteny plots
```{r}
long_ali <- subset(ali, alen > 1e4 & mapq > 40)
plot_synteny(long_ali, q_chrom="Q_chr3", t_chrom="T_chr4", centre=TRUE) +
    theme_bw()
```
```{r}
plot_synteny(long_ali, q_chrom="Q_chr5", t_chrom="T_chr5", centre=TRUE) +
    theme_bw()
```
```{r}
plot_synteny(long_ali, q_chrom="Q_chr5", t_chrom="T_chr5", 
             centre=TRUE, rc=TRUE) +
    theme_bw()
```
# Plot coverage by query sequence

```{r}
prim_alignment <- filter_secondary_alignments(ali)

plot_coverage(prim_alignment, fill="qname") +   
    scale_fill_brewer(palette="Set1") 
```


# Finished

show R version used, and package versions

```{r sessionInfo}
sessionInfo()
```
