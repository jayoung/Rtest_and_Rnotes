---
title: "logoPlots_and_jensenShannonDistance"
author: "Janet Young\n"
date: "`r Sys.Date()`\n"
output: github_document
always_allow_html: true
---

Goals:     
  - show how to make a logo plot    
  - show how to calculate Jensen-Shannon divergence between two (aligned) alignments at each position    

JSD is basically working - xxx tidy it up a lot and use tidyverse code

xxx add logo plot


# Load libraries

```{r setup, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# library(ggtree)
# library(ape)
# library(here)
library(Biostrings)
library(entropy)
```


# Define some functions

We define a function that matches Mike Doud's function to quantify measure of AA preference difference using the [Jensen-Shannon distance](https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence) 


```{r}
# myEnt is a function to get Shannon entropy. 
# x is a vector of numbers that sums to 1 representing amino acid frequencies at a given position in a single alignment. In my case it has length 21 (includes gap character, -)
myEnt <- function (x) {  entropy.empirical(x, "log2") }

# myJSD is a function to get JSD comparing two frequency profiles (prefs1 and prefs2)
myJSD <- function( prefs1, prefs2 ) {
    firstTerm <- myEnt( (prefs1 + prefs2)/2 )
    secondTerm <- (myEnt(prefs1) + myEnt(prefs2))/2
    myResult <- sqrt( firstTerm - secondTerm )
    return(myResult)
}

# myJSD_3classes is a function to get JSD comparing three frequency profiles (prefs1, prefs2 and prefs3). The upper bound of the three-class case is sqrt(log2(3)) = 1.258953
#  (that is correct according the wikipedia page)
myJSD_3classes <- function( prefs1, prefs2, prefs3 ) {
    firstTerm <- myEnt( (prefs1 + prefs2 + prefs3)/3 )
    secondTerm <- (myEnt(prefs1) + myEnt(prefs2) + myEnt(prefs3))/3
    myResult <- sqrt( firstTerm - secondTerm )
    return(myResult)
}

# myJSD_4classes is a function to get JSD comparing three frequency profiles (prefs1, prefs2, prefs3 and prefs4). The upper bound of the four-class case is sqrt(log2(4)) = 1.414214
myJSD_4classes <- function( prefs1, prefs2, prefs3, prefs4 ) {
    firstTerm <- myEnt( (prefs1 + prefs2 + prefs3 + prefs4)/4 )
    secondTerm <- (myEnt(prefs1) + myEnt(prefs2) + myEnt(prefs3) + myEnt(prefs4))/4
    myResult <- sqrt( firstTerm - secondTerm )
    return(myResult)
}
```

# read in alignments


# Read in example data: short H2A alignment (Antoine)

In this case I have a single alignment of the histone fold domain of various H2A family members. It contains canonical H2A, H2A.B, H2A.L, H2A.P (8 species each) and the marsupial-specific H2A.R (5 sequences) (total of 37 sequences).

I read in the alignment, figure out which H2A variant each sequence is from, and split the single master alignment into 5 individual alignments, one for each H2A variant.

```{r}
aln_file <- "exampleProtAln_shortH2As_histoneFoldDomain.fa"

masterAln <- readAAStringSet(aln_file)
# simplify the sequence names by removing the description
names(masterAln) <- sapply(strsplit(names(masterAln), " "), "[[", 1)
```

Then I figure out which variant each sequence is from and split the alignment into one smaller alignment per variant.

```{r}
# figure out which variant each sequence is from
masterAlnSeqTypes <- sapply(strsplit(names(masterAln), "_"), "[[", 1)
masterAlnSeqTypes <- gsub("R[12]$","R", masterAlnSeqTypes)
# table(masterAlnSeqTypes)

# split the alignment into those categories. We get a list object containing all 5 alignments
masterAlnSplit <- split(masterAln, masterAlnSeqTypes)
```


xxxx below here can be tidied

```{r}
### get count matrices in a way that includes every amino acid and the gap character:
myAAtoTabulate <- c("-", AA_STANDARD)
masterAlnSplit_counts <- lapply( masterAlnSplit, function(x) {
    y <- as.data.frame(consensusMatrix(x))
    missingRows <- setdiff (myAAtoTabulate, rownames(y))
    for (thisRow in missingRows) {
        y[thisRow,] <- rep(0, dim(y)[2])
    }
    y <- y[ myAAtoTabulate, ]
    y
} )

masterAlnSplit_frequencies <- lapply(masterAlnSplit_counts, function(x) {
    y <- x / colSums(x)
    y
})
```

```{r}

myJSD (masterAlnSplit_frequencies[["H2A"]][,7], masterAlnSplit_frequencies[["H2A.B"]][,7] )

```

```{r}

###
myDistances <- data.frame(row.names= paste(1:82, strsplit( as.character(masterAlnSplit[["H2A"]][[1]] ), "")[[1]], sep=""), pos=1:82 )
myDistances[,"BvsH2A"] <- sapply (1:dim(masterAlnSplit_frequencies[["H2A"]])[2], function (x) {
    myJSD(masterAlnSplit_frequencies[["H2A"]][,x], masterAlnSplit_frequencies[["H2A.B"]][,x] )
} )
myDistances[,"LvsH2A"] <- sapply (1:dim(masterAlnSplit_frequencies[["H2A"]])[2], function (x) {
    myJSD(masterAlnSplit_frequencies[["H2A"]][,x], masterAlnSplit_frequencies[["H2A.L"]][,x] )
} )
myDistances[,"PvsH2A"] <- sapply (1:dim(masterAlnSplit_frequencies[["H2A"]])[2], function (x) {
    myJSD(masterAlnSplit_frequencies[["H2A"]][,x], masterAlnSplit_frequencies[["H2A.P"]][,x] )
} )

myDistances[,"RvsH2A"] <- sapply (1:dim(masterAlnSplit_frequencies[["H2A"]])[2], function (x) {
    myJSD(masterAlnSplit_frequencies[["H2A"]][,x], masterAlnSplit_frequencies[["H2A.R"]][,x] )
} )
```

```{r, fig.height=3, fig.width=11}

plotXaxisFunction <- function() {
    axis(1, at=(myDistances[,"pos"]-0.5), labels=rownames(myDistances), las=2, cex.axis=0.5, tick=FALSE, hadj=0.4 )
}
plotYaxisFunction <- function(thisYmin=0) {
    myYmgp <- c(1.4, 0.8, 0)
    axis(2, at=c(thisYmin,1), labels=c(thisYmin,1), las=2, mgp=myYmgp)
    title(ylab="JSD", mgp=myYmgp)
}
myBarplot <- function(thisColName, thisTitle, thisYmin=0, ...) {
    barplot( myDistances[,thisColName], main=thisTitle, space=0, xaxs="i", yaxt="n", ...)
    plotXaxisFunction()
    plotYaxisFunction(thisYmin)
}
myBarplot( thisColName="BvsH2A", thisTitle="H2A.B vs H2A")

```


# Finished

show R version used, and package versions

```{r sessionInfo}
sessionInfo()
```


