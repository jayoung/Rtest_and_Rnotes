---
title: "divergence_metrics"
author: "Janet Young\n"
date: "`r Sys.Date()`\n"
output: github_document
always_allow_html: true
---

# Goal 

Play with code to look at divergence metrics in a multiple sequence alignment 



```{r setup, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(Biostrings)
library(pwalign)
library(here)
```

# Define some utility functions

Set up a couple of utility functions to degap alignments

```{r}
#### degapNucAln - function to remove columns that are entirely gap (or can use fractionOfSeqsWithGap to relax requirements of how many seqs have gap)
degapNucAln <- function(myAln, fractionOfSeqsWithGap=1) {
    maskedAln <- myAln %>% 
        DNAMultipleAlignment() %>% 
        maskGaps(min.fraction=fractionOfSeqsWithGap, 
                 min.block.width=1) %>% 
        DNAStringSet()
    return(maskedAln)
}


#### degapAAaln - function to remove columns that are entirely gap (or can use fractionOfSeqsWithGap to relax requirements of how many seqs have gap)
### this is how I can see maskGaps uses >= for the fractionOfSeqsWithGap threshold:
# selectMethod("maskGaps", "AAMultipleAlignment")
# newmask <- (m["-", ]/colSums(m)) >= min.fraction
degapAAaln <- function(myAln, fractionOfSeqsWithGap=1) {
    maskedAln <- myAln %>% 
        AAMultipleAlignment() %>% 
        maskGaps(min.fraction=fractionOfSeqsWithGap, 
                 min.block.width=1) %>% 
        AAStringSet()
    return(maskedAln)
}
```

# Read example alignments (DNA and protein)

Histon amino acid alignment

```{r}
aa_aln_histone <- here("Rscripts/multiple_sequence_alignments/example_alignment_files/exampleProtAln_shortH2As_histoneFoldDomain.fa") %>% 
    readAAStringSet()

names(aa_aln_histone) <- sapply(strsplit(names(aa_aln_histone), " "), "[[", 1)

aa_aln_histone
```

Get a smaller alignment, for testing 


```{r}
aa_aln_h2a_l <- aa_aln_histone[ grep("H2A.L", names(aa_aln_histone)) ] %>% 
    degapAAaln()

aa_aln_h2a_l_firstBit <- aa_aln_h2a_l %>% 
    narrow(start=1, end=12)
aa_aln_h2a_l_firstBit <- aa_aln_h2a_l_firstBit[1:4]

aa_aln_h2a_l_firstBit
```
## stringDist function

`stringDist()` (was in Biostrings, moved to pwalign package) 

It counts number of changes between all pairs of sequences, using various methods - "levenshtein", "hamming", "quality", or "substitutionMatrix".

(I checked - hamming and levenshtein give the same result for this particular alignment.)

Show Hamming distances for the tiny alignment:

```{r}
aa_aln_h2a_l_firstBit %>% 
    stringDist(diag=TRUE, upper=TRUE, method="hamming")
```
Further below I explore the other distance metrics.

## Understand how gaps are counted

To understand how gaps are counted, I make a very tiny alignment. I can see that a gap-to-AA mismatch is counted as distance 1.   I can also see that gap-to-gap positions count as 0 distance.


```{r}
aa_aln_h2a_l_firstBit_tiny <- aa_aln_h2a_l_firstBit[2:3] %>% 
    narrow(start=8, end=11)

temp <- aa_aln_h2a_l_firstBit_tiny[2]
names(temp) <- "H2A.L_mouse_again"
aa_aln_h2a_l_firstBit_tiny <- c(aa_aln_h2a_l_firstBit_tiny,
                                temp)

aa_aln_h2a_l_firstBit_tiny
```

### gap handling by stringDist 

```{r}
aa_aln_h2a_l_firstBit_tiny %>% 
    stringDist(diag=TRUE, upper=TRUE, method="hamming")
```



# Hamming versus Levenshtein distances


This [wikipedia page](https://en.wikipedia.org/wiki/Levenshtein_distance) explains the difference between hamming and Levenshtein distances.  Levenshtein distance essentially allows indels.

Example - lawn versus flaw:
```{r}
y <- c("lawn","flaw")
x <- BStringSet(y)
names(x) <- y
x
```

```{r}
x %>% stringDist(diag=TRUE, upper=TRUE, method="hamming")
```


```{r}
x %>% stringDist(diag=TRUE, upper=TRUE, method="levenshtein")
```



Show levenshtein distances for the real tiny alignment:

```{r}
aa_aln_h2a_l_firstBit %>% 
    stringDist(diag=TRUE, upper=TRUE, method="levenshtein")
```


Haven't run substitutionMatrix distances, because it requires providing a matrix using substitutionMatrix argument, and I haven't tracked down an amino acid matrix that works. This code failes:

```{r}
# data(BLOSUM62)
# aa_aln_h2a_l_firstBit %>% 
#     stringDist(diag=TRUE, upper=TRUE, 
#                method="substitutionMatrix",
#                substitutionMatrix=BLOSUM62)
# Error in .Call2("XStringSet_align_distance", x, type, typeCode, gapOpening,  : 
#   key 45 not in lookup table
```


Show quality distances for the tiny alignment. I have no idea what this is - I can only imagine it's something intended for phred scores and it's inappropriate to use here.

```{r}
aa_aln_h2a_l_firstBit %>% 
    stringDist(diag=TRUE, upper=TRUE, method="quality")
```


# Play with `pwalign` package 

See [documentation](https://bioconductor.org/packages/release/bioc/vignettes/pwalign/inst/doc/PairwiseAlignments.pdf)

`PairwiseAlignmentsSingleSubject()` :

```{r}
temp <- aa_aln_h2a_l_firstBit[1:2]
temp2 <- temp %>% PairwiseAlignmentsSingleSubject()
nmatch(temp2)
nmismatch(temp2)
# mismatchTable(temp2)
deletion(temp2)
insertion(temp2)
indel(temp2)
nchar(temp2)
pid(temp2)
```


"PID1": 100 * (identical positions) / (aligned positions + internal gap positions)
"PID2": 100 * (identical positions) / (aligned positions)
"PID3": 100 * (identical positions) / (length shorter sequence)
"PID4": 100 * (identical positions) / (average length of the two sequences)


# Finished

```{r}
sessionInfo()
```



