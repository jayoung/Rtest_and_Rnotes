---
title: "alignment_coordinates"
author: "Janet Young\n"
date: "`r Sys.Date()`\n"
output: github_document
always_allow_html: true
---

# Goal 

given coordinates of one or more features in a reference sequence, figure out what the coordinates are in an alignment that contains the reference sequence


# Load libraries

```{r setup, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(here)

## Biostrings is a bioconductor package, not a regular R package. This page has instructions on how to install it:
## https://bioconductor.org/packages/release/bioc/html/Biostrings.html
library(Biostrings)
```

# Read example alignment:

```{r}
## readDNAStringSet is a Biostrings function that reads a multi-sequence fasta file
## readAAStringSet is the amino acid equivalent
aln <- readDNAStringSet("example_alignment_files/cenH3_aln9.nt.fa")

# get rid of descriptions in the sequence names
names(aln) <- sapply( strsplit(names(aln), " "), "[[", 1)
```


What does it look like?

34 sequences in the alignment (rows) and 492 aligned positions (columns)

```{r}
aln
```


Define which sequence is our reference - the sequence to which coordinates refer

```{r}
ref_name <- grep("human_", names(aln), value=TRUE)
ref_name
```



Set up a couple of functions

`getUngappedPosOneSeq` takes a single gapped sequence (i.e. a sequence in the alignment), and gets a tibble of position in each sequence versus position in alignment. We use cumulative sum of non-gap bases.

`makeLookupTibble` is a bigger function that applies the `getUngappedPosOneSeq` to every sequence in an alignment and returns a tibble


```{r}
###### getUngappedPosOneSeq is a function to take a single aligned sequence, and to return a number for each position in the alignment that represents the position in the original sequence
## myGappedSeq is a DNAString (or AAString/BString, etc)
getUngappedPosOneSeq <- function(myGappedSeq) {
    # split the aligned sequence into individual characters
    mySeq <- strsplit(as.character(myGappedSeq),"")[[1]]
    # as we go along the aligned sequence from start to finish, count how many non-gap characters we have encountered
    myCounts <- cumsum(mySeq != "-")
    # gaps in the aligned sequence should have no coordinate - change those counts to NA
    myCounts[which(mySeq=="-")] <- NA
    return(myCounts)
}

##### makeLookupTibble - a function to take an alignment, and for every single sequence, get a position lookup table, and join the together
makeLookupTibble <- function(alignment) {
    output <- tibble(aln_pos=1:width(alignment)[1])
    each_seq_lookup <- sapply( names(alignment), function(each_seq_name) {
        getUngappedPosOneSeq( alignment[[each_seq_name]] )
    } ) 
    output <- bind_cols(output, each_seq_lookup)
    return(output)
}
```

Make a position lookup tibble for our alignment, considering only the reference sequence that our features are defined in.  Show the last few rows of the tibble.

```{r}
alnPos_lookup_table <- makeLookupTibble( aln[ref_name] )

alnPos_lookup_table %>% 
    tail()
```


Generate example features, with coordinates in the reference sequence

```{r}
human_features <- tibble(
    name=c("region1","region2","region3"),
    start=c(1, 101, 331),
    end=c(90,140,400),
    strand="+"
) 
human_features
```


Set up another function called `addAlnCoords` that will use the lookup table, and the feature table, and will convert coordinates in the reference sequence into coordinates in the alignment

```{r}
addAlnCoords <- function(feature_tbl,
                         lookup_tbl, 
                         refseq_name) {
    ## check the ref sequence is present in the lookup tbl
    if(! refseq_name %in% colnames(lookup_tbl)) {
        stop("\n\nERROR - could not find refseq called ",
             refseq_name, "in the lookup_tbl colnames\n\n")
    }
    
    ## get lookup tbl in a useful format
    lookup_tbl <- lookup_tbl %>% 
        select(aln_pos, ref_pos=matches(refseq_name))
    
    # look up start aln_pos
    feature_tbl <- left_join(feature_tbl,
                             lookup_tbl,
                             by=c("start"="ref_pos") ) %>% 
        rename(start_aln=aln_pos)
    # look up end aln_pos
    feature_tbl <- left_join(feature_tbl,
                             lookup_tbl,
                             by=c("end"="ref_pos") ) %>% 
        rename(end_aln=aln_pos)
    return(feature_tbl)
}
```

Use `addAlnCoords` with our lookup table to convert coordinates in the example features tibble (`human_features`)

```{r}
human_features <- addAlnCoords( feature_tbl=human_features, 
                                lookup_tbl=alnPos_lookup_table, 
                                refseq_name=ref_name )
```


# Tabulate every position in the alignment

The `consensusMatrix()` function (Biostrings) can tabulate what's present at each alignment site (column):

It gives us a matrix object with a row for each nucleotide (class) it counted, and a column for each alignment position. Here are counts for the first 10 positions

```{r}
## as a reminder, our alignment has 34 seqs and 492 positions
aln_counts <- consensusMatrix(aln, baseOnly=TRUE)
aln_counts[,1:10]
```
Maybe we want to use the lookup table we made earlier to add human positions on to that alignment

First, let's turn that matrix 90 degrees and make it into a tibble, which will be easier to work with
```{r}
aln_counts <- aln_counts %>% 
    t() %>% 
    as.data.frame() %>% 
    as_tibble(rownames="aln_pos") %>% 
    mutate(aln_pos=as.integer(aln_pos))

aln_counts %>% 
    head()
```

Use `left_join()` to add the human positions

```{r}
aln_counts <- left_join(aln_counts,
                        alnPos_lookup_table, 
                        by="aln_pos") %>% 
    relocate(human_CENPA_ORF, .after=aln_pos) %>% 
    dplyr::rename(human_pos=human_CENPA_ORF)
aln_counts
```

Add the nucleotide in human 

```{r}

human_nucs <- aln[[ref_name]] %>% 
    as.character() %>% 
    str_split("")
human_nucs <- human_nucs[[1]]

aln_counts$human_nuc <- human_nucs

aln_counts <- aln_counts %>% 
    relocate(human_nuc, .after=human_pos)
aln_counts
```


Perhaps we drop the positions where human has a gap - we might not care about those

```{r}
aln_counts <- aln_counts %>% 
    filter(human_nuc != "-")
aln_counts
```



## Extracting aligned regions

Get those three regions from the alignment - we use the `narrow` function

```{r}
human_feature_alns <- lapply(1:nrow(human_features), 
                             function(i) {
    narrow(aln, 
           start=human_features$start_aln[i],
           end=human_features$end_aln[i] )
})
```


We can use the `xscat` function to join those alignment pieces together.

Here's the simplest way to use `xscat`.  

```{r}
xscat(human_feature_alns[[1]],
      human_feature_alns[[2]],
      human_feature_alns[[3]])
```

However, using `xscat` that way is not very generalizable, e.g. if we have a large list, or if we don't know head of time how long our list is:

A better way, perhaps is to wrap `xscat` inside the `do.call` function - it is a function that I think of as "unpacking" a list and running a function on all the elements together:

```{r}
do.call("xscat", human_feature_alns)
```

# Finished

```{r}
sessionInfo()
```


