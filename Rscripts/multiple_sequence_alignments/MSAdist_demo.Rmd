---
title: "MSAdist_demo"
author: "Janet Young\n"
date: "`r Sys.Date()`\n"
output: html_document
---


# Play with MSA2dist package

See [documentation](https://bioconductor.org/packages/release/bioc/vignettes/MSA2dist/inst/doc/MSA2dist.html)

```{r}
library(tidyverse)
library(MSA2dist)
library(Biostrings)

# output: github_document
# always_allow_html: true

# load example data
data(hiv, package="MSA2dist")
data(AAMatrix, package="MSA2dist")
data(woodmouse, package="ape")
```

The `hiv` dataset is a DNAStringSet object, 13 DNA seqs, each 273bp in length (91aa)

```{r}
hiv
```

`MSA2dist::cds2aa` translates DNA seqs, has some options regarding which reading frame. Creates an AAStringSet object

```{r}
hiv_aa <- cds2aa(hiv) 
hiv_aa
```


```{r}
simple_percent_identity_pairwise <- function(twoSeqs_stringSet) {
    if(length(twoSeqs_stringSet) != 2) {
        stop("\n\nERROR - input does has the wrong number of sequences - function designed to work on just two sequences\n\n")
    }
    if(width(twoSeqs_stringSet)[1] !=  width(twoSeqs_stringSet)[2]) {
        stop("\n\nERROR - seqs don't have the same length as each other\n\n")
    }
    output <- tibble(seq1=names(twoSeqs_stringSet)[1],
                     seq2=names(twoSeqs_stringSet)[2] ) %>% 
        ## strip off description, if there is one
        mutate(seq1 = sapply(strsplit(seq1, " "), "[[", 1)) %>% 
        mutate(seq2 = sapply(strsplit(seq2, " "), "[[", 1))
    
    twoSeqs <- as.matrix(twoSeqs_stringSet) %>% 
        t() %>% 
        as_tibble()
    colnames(twoSeqs) <- c("seq1", "seq2")
    
    twoSeqs_degapFullGap <- twoSeqs %>% 
        filter(!(seq1=="-" & seq2=="-"))
    output$aln_len <- nrow(twoSeqs_degapFullGap)
    
    output$num_identical <- sum(twoSeqs_degapFullGap$seq1 == twoSeqs_degapFullGap$seq2)
    
    twoSeqs_degapAnyGap <- twoSeqs_degapFullGap %>% 
        filter(seq1 != "-" & seq2 != "-")
    output$aln_len_nogaps <- nrow(twoSeqs_degapAnyGap)
    
    output <- output %>% 
        mutate(pid_incl_gap = 100*num_identical / aln_len) %>% 
        mutate(pid_excl_gap = 100*num_identical / aln_len_nogaps)
    return(output)
}

simple_percent_identity_multiple <- function(one_aln) {
    if(length(unique(width(one_aln)))>1) {
        stop("\n\nERROR - these are not aligned seqs - they have different lengths: ", 
             paste(width(one_aln), collapse=","),
             "\n\n")
    }
    lapply(1:(length(one_aln)-1), function(i) {
        lapply( (i+1):length(one_aln), function(j) {
            simple_percent_identity_pairwise(one_aln[c(i,j)])
        }) %>% 
            bind_rows()
    }) %>% 
        bind_rows()
}

```

```{r}
hiv_aa_myDists <- simple_percent_identity_multiple(hiv_aa[1:4])
as.matrix(hiv_aa_myDists)
```

```{r}
my_percent_id_to_matrix <- function(my_percent_id_tbl,
                                    col_to_take="pid_excl_gap") {
    my_seqorder <- unique(c(my_percent_id_tbl$seq1,
                            my_percent_id_tbl$seq2))
    ## first make it symmetrical
    my_percent_id_tbl_flip <- my_percent_id_tbl %>% 
        dplyr::rename(seq1_new=seq2, 
                      seq2_new=seq1) %>% 
        dplyr::rename(seq1=seq1_new, 
                      seq2=seq2_new)
    my_percent_id_tbl_both <- bind_rows(my_percent_id_tbl,
                                        my_percent_id_tbl_flip) 
    # return(my_percent_id_tbl_both)
    my_percent_id_tbl_both <- my_percent_id_tbl_both %>% 
        select(seq1, seq2, value=all_of(col_to_take))
    # return(my_percent_id_tbl_both)
    my_matrix <- my_percent_id_tbl_both %>%
        pivot_wider(id_cols="seq1",
                    values_from="value",
                    names_from="seq2", 
                    values_fill=0)
    
    my_matrix_v2 <- as.matrix(my_matrix[,my_seqorder])
    rownames(my_matrix_v2) <- my_matrix$seq1
    my_matrix_v2 <- my_matrix_v2[my_seqorder,]
    return(my_matrix_v2)
}
# temp <- hiv_aa_myDists %>% my_percent_id_to_matrix() 
temp <- hiv_aa_myDists %>% 
    mutate(num_diff=aln_len-num_identical) %>% 
    my_percent_id_to_matrix(col_to_take="num_diff") 
temp 
```


# Use MSA2dist distance functions

aastring2dist gets a distances matrix. We need to specify scoring matrix - the vignette uses Grantham scores. 

Returns a list of three items [1] "distSTRING" "sitesUsed"  "regionUsed"

Something is wrong on my computer!  doesn't display right at all. Should be a numeric matrix.

```{r}
hiv_aa_dist <- aastring2dist(hiv_aa, 
                             score=granthamMatrix())

# lapply(hiv_aa_dist, class)
# hiv_aa_dist[["distSTRING"]] %>% head()
# head(hiv_aa_dist$distSTRING)

# distSTRING = matrix of distances
# sitesUsed = matrix of number of sites used
# regionUsed = IRanges object specifying which part of the alignment was used (default is the whole thing)
```

Show the distances between the first 4 seqs (wrap in as.matrix for now, because of a weird rendering bug probably with Rstudio)

```{r}
as.matrix(hiv_aa_dist[["distSTRING"]][1:4, 1:4])
```

Printing this matrix looks really wierd in the Rstudio/Rmd rendering but it looks OK under most other circumstances, e.g. if I wrap in `as.matrix()`, when I knit, and if I print in the console. I think something is going wrong in my Rstudio. Probably need a new version or to restart my computer or something.


To use a different score matrix, here as an example the AAMatrix from the R package alakazam is used:

```{r}
head(AAMatrix)
```

These numbers are the parwise scores calculated from the scoring matrix, divided by the aligned length:

```{r}
aa.dist.AAMatrix <- aastring2dist(hiv_aa, score=AAMatrix)
as.matrix(aa.dist.AAMatrix[["distSTRING"]][1:4, 1:4])
```

Multiply by the aligned length to get the number of mismatches (this is the same as my function gives):

```{r}
as.matrix(aa.dist.AAMatrix[["distSTRING"]][1:4, 1:4] * 91)
```

# DNA distance

```{r}
dna.dist <- dnastring2dist(hiv, model="K80")
as.matrix(dna.dist[["distSTRING"]][1:4, 1:4])

```

# Ka/Ks

There are tons of models available for Ka/Ks calculations

```{r}
ka_ks_li <- dnastring2kaks(hiv, model="Li")
head( as.matrix( ka_ks_li ) )
```

```{r}
ka_ks_YN <- dnastring2kaks(hiv, model="YN")
head( as.matrix( ka_ks_YN ) )
```

## average behavior each codon

dnastring2codonmat turns a DNA alignment into a matrix of codons. One row per codon slice of the alignment, one column per sequence in the alignment

codonmat2xy does calculations for each codon position. "This function calculates average behavior of each codon for all pairwise comparisons for indels, syn, and nonsyn mutations according to Nei and Gojobori (1986)."


Output:

- n is number of pairwise comparisons

```{r}

hiv.xy <-  codonmat2xy(dnastring2codonmat(hiv))

head(as.matrix(hiv.xy))

```


## Grantham scores

I found [this info](https://gist.github.com/danielecook/501f03650bca6a3db31ff3af2d413d2a), not sure how correct it is: 

[Grantham scores](https://www.science.org/doi/10.1126/science.185.4154.862), which categorize codon replacements into classes of increasing chemical dissimilarity, were designated conservative (0-50), moderately conservative (51-100), moderately radical (101-150), or radical (â‰¥151) according to the classification proposed by Li et al. (28).  These numbers are estimated by looking at the frequency of all pair-wise amino acid substitutions between species. 




# Finished

```{r}
sessionInfo()
```
